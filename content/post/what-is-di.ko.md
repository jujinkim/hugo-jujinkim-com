---
title: "DI(의존성 주입)란 무엇일까?"
date: 2020-10-18T01:12:39+09:00
draft: true
---
&nbsp;이 글은 Dagger2를 공부하기에 앞서 DI(의존성 주입)라는게 무엇인지 도저히 모르겠는 분들을 위한 글입니다. 네, 저를 위한 글입니다.

## DI란 무엇인가?

&nbsp;DI는 의존성 주입(Dependency Injection)의 약자로, **어떤 객체의 의존성을 외부에서 주입시켜주는 프로그래밍 설계 기법**입니다. 무슨 말인지 모르겠다구요? 네, 저도 모르겠습니다. 뭘 주입한다는건지도 모르겠고, 알았다 하더라도 이걸 왜 써야하는지 모르겠단 말입니다. 그래서 이 글을 썼습니다. 

&nbsp;DI 특징을 정의하기에 앞서, 일상에서의 어떤 상황을 상상해보겠습니다.

> 당신은 지금 배가 고파서 분식집에 들어갔고, 라면을 주문했습니다.

&nbsp;요리사는 라면 조리를 시작할 것입니다. 재료(준비물)로는 물, 면, 소스, 그리고 냄비가 필요합니다. 조리 과정은 "냄비에 물, 소스, 면을 넣은 후 끓인다" 가 될 것입니다.   
&nbsp;여기서 요리사는 재료들을 어디서 구해왔을까요? 당연히 외부에서 사왔을 거에요. 직접 물, 소스, 면, 냄비를 생산해내지 않고 밖에서 구해왔을 것입니다. 이렇게 외부에서 공급받는 것을 DI(의존성 주입)이라고 합니다.

> 요리사가 라면을 만들기 위해선 물, 면, 소스 그리고 냄비가 필요합니다. 즉, 이 네 가지에 **의존**해서 라면을 만드는 것입니다. 하나라도 없으면 만들 수 없으니까요. 그리고 요리사는 이것들을 외부에서 구해옵니다. 다른말도 하면, 외부로부터 재료들을 **주입**받는다고 할 수도 있겠습니다. 그래서 **의존성 주입**이라고 하는 것입니다.

&nbsp;만약 재료(준비물)들을 사오지 않는다면 요리사가 라면을 조리하는 과정은 조금 복잡해집니다. "물을 만들고, 면을 만들고, 소스를 만들고, 냄비를 만든다. 그리고 냄비에 재료들을 넣고 끓인다" 가 조리 과정이 되겠지요.  
&nbsp;요리사가 모든걸 다 하니까 좋아보이겠지만, 생각해보면 그다지 좋은 것은 아닙니다. 요리사는 말 그대로 요리하는 사람이지, 재료를 만드는 사람은 아니니까요. 코딩도 비슷합니다. 코딩에서는 '역할의 분리'가 중요한데, 무슨 말이나면 하나의 메서드는 한 가지 일만, 클래스는 명확한 목적만을 수행하도록 만들어지는 게 좋다는 뜻입니다. 이것은 수정사항이 생겼을 때 코드의 불필요한 수정을 최소화하고, 재사용 및 테스트를 용이하게 만들기 위함입니다. 실제로 우리가 일할 때에도 위에서 이것저것 다 시키는 것 보다는 한 가지 일에만 집중할 때 일의 효율이 올라가듯이, 코드도 비슷합니다. 시키는 사람에게는 대충 한 사람이 알아서 다 해주면 처음에는 좋겠지만, 규모가 커진다면 일이 생겼을 때에 누구를 시켜야 하는지 애매해지죠. 이런저런 이유로 역할의 분리가 중요하며, DI는 이 문제를 처리해줍니다.

&nbsp;이제 요리사가 라면을 조리하는 과정을 코드로 만들어보겠습니다.

---

## DI를 사용하지 않은 요리사

먼저, 재료(준비물)들을 정의하겠습니다.
```kotlin
// 재료들
class Noodle {}
class Sauce {}
class Water {}
class RamenBowl {
    fun makeRamen(water: Water, sauce: Sauce, noodle: Noodle): Ramen {
        return Ramen(water, sauce, noodle)
    }
}

// 라면 (결과물)
class Ramen(water: Water, sauce: Sauce, noodle: Noodle) {}
```

&nbsp;일반적인 방법(DI 안쓴방법)으로 코드를 짠다면 이 코드가 라면을 조리하는 요리사의 클래스 정의입니다.
```kotlin
class Chef {
    fun cookRamen(): Ramen {
        val noodle = Noodle()
        val sauce = Sauce()
        val water = Water()
        val bowl = RamenBowl()

        val ramen = bowl.makeRamen(water, sauce, noodle)
        return ramen
    }
}
```
&nbsp; `Chef`는 `cookRamen()` 메소드로 라면을 조리하는 방법을 알고 있습니다. 그런데 이 코드대로다면 **라면을 조리하는 과정에 면, 소스, 물과 냄비를 만드는 과정이 포함**됩니다, 이상하죠. 밥을 시켰는데 쌀부터 만들어오라고 주문을 하는 것이지요. 그리고, 이 라면 만드는 과정(`cookRamen()`)을 시험하고싶다면 어떻게 되는걸까요? 이 코드대로라면, 라면을 만드는 과정 뿐만 아니라 재료를 생산하는 과정까지 테스트를 하는 꼴이 됩니다. 이상하죠, 마스터쉐프코리아에서 요리사들 평가할 때 재료를 생산하는 과정까지 평가하지는 않잖아요?

&nbsp;코딩의 관점에서 위 방법대로 구현한다면 나중에 귀찮아 질 수 있는 문제도 있습니다. 만약 라면 말고 물이 필요한 다른 요리를 하는 요리사(`Chef`)도 있다고 할 때, 물(`Water`)의 생성자에 매개변수가 추가된다면 `모든 물을 사용하는 Chef 클래스들의 물 생성 코드를 수정`해줘야합니다. 또, 뭘 만들 때마다 재료를 생산하기 때문에 객체 생성 코드(`val water = Water()` 등)를 여러곳에서 쓰는 `중복 코드`도 발생할 수 있습니다.

---
## DI 1단계: 재료를 외부에게서 공급받도록 한다.
&nbsp;글 처음에 써있듯이, 요리사는 라면을 만드는 재료를 만들지 않습니다. 그럼 어디서 재료를 구할까요? 우선, 사장님이 재료를 주고 요리하라고 시켰을 수 있습니다. 그럼 아래와 같이 요리사 클래스 코드를 바꿀 수 있습니다.

```kotlin
class Chef {
    fun cookRamen(water: Water, 
                  sauce: Sauce, 
                  noodle: Noodle, 
                  bowl: RamenBowl): Ramen {
        val ramen = bowl.makeRamen(water, sauce, noodle)
        return ramen
    }
}
```
&nbsp;이제 요리사는 라면 조리를 할 때 직접 재료를 만들지 않고, 누군가가 준 재료들을 가지고 조리합니다. 조리 테스트를 할 때에도 순수하게 라면을 만드는 과정만 시험할 수 있겠네요.  
&nbsp;하지만 여전히 문제가 있습니다. 조리 하라고 시키는 누군가가 재료를 구해줘야한다는 것입니다. `cookRamen()`을 호출할 때 매개변수를 채워줘야해요. 실제로는 시키는 사람이 재료를 만들어주지는 않을텐데말이죠.

---
## DI 2단계: 재료를 공급하는 곳을 만든다.
&nbsp;그럼 재료는 어디에서 가져와야 하는걸까요? 아무래도 시장에서 사오지 않을까요? 그래서 시장(`Market`)을 만들어주겠습니다.

```kotlin
class Market {
    fun getNoodle(): Noodle = Noodle()
    fun getSauce(): Sauce = Sauce()
    fun getWater(): Water = Water()
    fun getRamenBowl(): RamenBowl = RamenBowl()
}
```
&nbsp;이제 시장이 생겼으니 요리사는 라면 주문을 받으면 재료를 구해와서 조리하면 됩니다.
```kotlin
class Chef(val market: Market) {
    fun cookRamen(): Ramen {
        val water = market.getWater()
        val sauce = market.getSuace()
        val noodle = market.getNoodle()
        val bowl = markget.getRamenBowl()

        val ramen = Ramen(water, sauce, noodle, bowl)
        return ramen
    }
}
```
&nbsp;요리사가 재료를 구해오든, 아니면 `cookRamen()`의 매개변수로 재료를 받든간에 아무튼 요리사나 사장님은 더 이상 재료를 직접 만들 필요는 없어졌습니다.

&nbsp;그래도 조금 어색합니다. 보통 시장은 자기가 파는 물건을 직접 만들지는 않잖아요? 납품받아서 팔지. 시장은 유통해줄 뿐, 제품을 생산하는 곳은 따로 있습니다. 그리고 자주 시장에서 물건을 사다 보면 다음부터는 일일이 항목별로 사지 않고, 아예 묶어서 구입하기도 합니다.

---
## DI 3단계: 재료를 만드는곳, 공급하는 곳, 사용하는 곳으로 나눈다.
&nbsp;만드는 곳, 파는 곳, 쓰는 곳으로 역할을 나눠보겠습니다. 

```kotlin

```
&nbsp;이제야 산업혁명 후 발전된 현대 사회의 모습이 코드에서 보이네요.







&nbsp;이 글에서는 제가 나름대로 이해한 DI를 적었습니다. 많은 분들이 이 글을 보고 좋는 느낌을 얻어가셨으면 좋겠습니다. DI는 확실히 손이 많이 가는 설계이지만, 알아두면 정말 많은 부분에서 새로운 영감을 얻으실 것입니다. 혹시나 애매하거나 틀린부분이 있다면 지적해주시면 참고하겠습니다.